## 개요
실제로 구축해 본 경험도 있기 때문에 조금 더 흥미있게 읽었던 파트였습니다.
해당 장에서는 IOS, 안드로이드, SMS 메시지, 이메일을 지원하는 알림 시스템의 개략적 설계안에 대해 다룹니다.

간단하게 정리해보면,
+ 알람 발송 매체는 IOS, 안드로이드, SMS 메시지, 이메일을 지원합니다.
+ 알림을 생성할 수 있는 주체는 클라이언트 애플리케이션 프로그램, 서버 스케쥴링 총 두 가지 입니다.
+ 특정 사용자는 해당 알림을 받지 않도록 설정할 수 있어야 합니다.
+ 하루에 천만 건의 모바일 푸시 알림, 백만 건의 SMS 메시지, 5백만 건의 이메일을 보낼 수 있어야합니다.

이러한 사항들을 만족시키는 알림시스템을 설계하는 장이다.

## 알림 유형 별 지원 방안
IOS와 안드로이드, SMS 서비스 모두 도식상으로 같지만, 알림을 단말로 발송하는 매개체가 APNS, FCM, SMS 서비스로 각각 다르다.
![](https://velog.velcdn.com/images/kjy0349/post/58934917-a0c3-4305-8f7c-07d860f62ffb/image.png)

![](https://velog.velcdn.com/images/kjy0349/post/e458d94a-0d1d-4302-8e17-5d0d3d945591/image.png)

![](https://velog.velcdn.com/images/kjy0349/post/d10ffdf2-51b3-472d-8f27-697d04639d59/image.png)

추가적으로 이메일 또한 중간 서비스를 센드그리드, 메일침프와 같은 서비스를 이용한다면 이메일 발송 또한 같은 유형으로 전송이 가능하다.

대부분의 회사는 메일 서버를 구축할 역량이 있지만, 해당 서비스들을 이용하면 데이터 분석 서비스를 제공함과 동시에 전송 성공률이 높이 때문에 해당 서비스들을 사용한다.

## 구성도
그래서 아래 그림과 같이 해당 서비스들을 묶어 한 시스템에 구축하고, 각 단말에 따라 서비스를 선택해 발송하는 형식을 채택한다.

다른 단말을 추가로 지원하고 싶을 경우, 아래쪽에 해당 단말에 대한 전송을 지원하는 서비스를 추가하는 식으로 확장할 수 있다.

다만, 해당 방식의 경우 알림 서비스 서버가 1개이므로 해당 서버에 문제가 생길 경우 전체 알림 발송에 문제가 생긴다는 것을 말한다. 또한, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.

![](https://velog.velcdn.com/images/kjy0349/post/18ad7a13-050f-4d43-9c9b-80e34be8950b/image.png)

## 개선 후 구성도
이러한 문제를 해결하기 위해 알림 시스템에서 캐시와 데이터베이스를 분리하고, 알림 발송 요청을 처리하는 서버를 각각 두는 형식으로 해결할 수 있다.

![](https://velog.velcdn.com/images/kjy0349/post/5118ed86-016e-44d4-8a04-b30454159fb4/image.png)


## 주요 컴포넌트에 대한 설명
1. 1 ~ N까지의 서비스 : 알림 API를 통해 알림을 보낼 서비스 들
2. 알림 서버
	
    + 알림 검증 : 이메일 주소, 전화번호 등에 대한 기본적 검증
    + 데이터베이스 또는 캐시 질의 : 알림에 포함시킬 데이터를 가져오는 기능
    + 알림 전송 : 알림 데이터를 메시지 큐에 넣어 작업 서버에서 처리할 수 있도록 함
    + 알림 전송 API : 사내 서비스 또는 인증 된 클라이언트에서 요청을 받아 알림을 전송

3. 캐시, 데이터베이스 : 사용자 정보, 단말 정보 등을 캐시 및 저장한다.
4. 메시지 큐 : 시스템 컴포넌트 간 의존성을 제거하기위해 사용. 알림 서버에 문제가 생기더라도, request들은 메시지 큐에 보관되기 때문에 결합도를 낮출 수 있다.


## 상세설계
구성 후, 고민해야 할 상세사항들은 다음과 같다.
+ 안정성
+ 추가로 필요한 컴포넌트 및 고려사항 : 알림 템플릿, 알림 설정, 전송률 제한, 재시도 메커니즘, 모니터링..

가장 중요한 것은, 어떠한 상황에도 **알림이 소실되면 안 되는 것**이다. 이를 위해 알림 시스템은 알림 데이터를 데이터베이스에 보관하고, 재시도 매커니즘을 구현해야한다. 작업 서버에서 알림 로그 데이터베이스를 추가하는 것으로 해결할 수 있다.

또한, 한 번 발송한 알림은 중복 발송하지 말아야 하므로, 중복을 탐지하는 매커니즘을 도입해야 한다.

1. 전송률 제한 : 한 사용자가 받을 수 있는 알림의 빈도를 제한해야 한다. 한 사용자가 너무 많은 알림을 받으면, 사용자가 해당 알림을 비활성화할 수 있기 때문이다.

2. 큐 모니터링 : 알림 시스템은 언제든지 부하가 발생할 수 있으므로, 각 큐에 담겨 아직 발송되지 않은 알림의 수를 모니터링 해야 한다. 이 수가 너무 크다면 작업 서버들이 빠르게 알림을 처리하지 못하고 있는것 이므로, 작업 서버를 증설해야 한다.

3. 이벤트 추적 : 알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율과 같은 메트릭을 통해 알림이 효과를 나타내고 있는지 검증해야 한다. 데이터 분석 서비스의 경우 작업 서버에서 알림을 발송할 때, 데이터 분석 서비스에도 전송해 알림 발송 상태를 추적하고, 추가적으로 각 단말에서의 클릭 이벤트도 추적해 데이터 분석 서비스로 보내주어야 한다.


## 마무리
이외에도, 전송 템플릿을 사용해 알림 생성 과정을 단순화하고 일관성을 유지하는 등의 추가 구현 사항이 있다. 위의 설계 과정을 통해 여러 장점을 가질 수 있었다.

### 최종 설계도
![](https://velog.velcdn.com/images/kjy0349/post/488bbc68-d645-436e-878f-ac4b02698704/image.png)


+ 안정성 : 메시지 전송 실패율을 낮추기 위해 재시도 매커니즘을 도입했다.
+ 보안 : 인증된 클라이언트만이 알림을 보낼 수 있도록 했다.
+ 이벤트 추적 및 모니터링 : 알림이 만들어진 후 전송되기까지의 과정을 추적하고, 상태를 모니터링하기 위한 시스템을 추가했다.
+ 사용자 설정 : 사용자가 알림 수신 설정을 조정할 수 있도록 했다.
+ 전송률 제한 : 사용자에게 알림을 보내는 빈도를 제한할 수 있도록 했다.

