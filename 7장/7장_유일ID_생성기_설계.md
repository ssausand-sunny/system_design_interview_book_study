## Intro
분산시스템에서 사용되는 유일 ID (PK)값을 설계 해보자!

---

## 전제
본 책에서는 해당 시스템의 설계를 하기 위해 서비스의 규모에 대한 전제가 섞여져 있다.
이를 정리하면 다음과 같다.
 - ID는 유일해야 한다.
 - ID는 숫자로 구성되어야 한다.
 - ID는 64비트로 표현되어야 한다.
 - 발급 날짜에 따라 정렬이 가능해야 한다.
 - 초당 10,000개의 ID를 발급해야 한다.

5개의 전제 조건을 가진 유일 ID를 설계하는 방법을 소개하겠다.

---

## 여러가지 방법들
사실 겹치지 않는 유일한 ID를 생성하는 방법을 많이 존재한다.
본 책에서는 그 방법들을 나열하면 다음과 같다.

 - 다중 마스터 복제 ( multi-master replication)
 - UUID (Universally Unique Identifier)
 - 티켓 서버 (ticket server)
 - 트위터의 스노플레이크(twitter snowflake) 접근법

각각의 방법에 대하여 소개해 보겠다.

---

### 다중 마스터 복제
다중 마스터 복제의 경우 데이터베이스의 auto_increment 속성을 이용하여 유일 ID를 설계하는 것이다. 여기서 auto_increment 되는 값은 가용중인 서버의 갯수로 선정한다.

ex) 가령 3개의 서버를 가용하는경우 auto_increment 는 3으로 선정하여 유일 ID를 보장한다.

| 서버 | 유일 ID |
| --- | --- |
|server 1 | 1,4,7 ... |
|server 2 | 2,5,8 ... |
|server 3 | 3,6,9 ... |

이 방식을 사용하는 경우 규모 확장성은 어느정도 해결이 가능하다. 데이터 베이스가 확장됨에 따라 초당 id 생성수가 증가하기 때문에 
다만, 이런 방식의 경우 만들려는 시스템에 적용하기에는 여러 단점이 존재하게 되는데...
 - #### 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.    
    데이터 센터에 있는 데이터베이스들까지 가용한다고 가정하면 auto_increment 값이 점점 늘어나게 된다.
 - #### ID의 유일성은 보장되지만 그 값이 시간에 맞추어 커지도록 보장할 수는 없다.    
    1번 데이터베이스의 값이 5개가 추가되서 1, 3, 5, 7, 9 의 ID를 가질때, 2번 데이터베이스에 값이 추가된다면 2의 ID를 가진다.    
    2의 ID는 9번보다 늦게 생성되었지만.. 값이 더 낮은 결과를 가져온다..
 - #### 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.    
    기존의 데이터센터에 서버를 더 추가하게 된다면 모든 데이터베이스의 제약조건을 수정해야 하는 불상사가 발생한다.

---

### UUID
UUID는 너무도 유명한 유일한 ID를 만드는 방법중 하나이다. UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트의 수다.
UUID는 충돌가능성이 굉장히 낮다. 위키피디아에 의하면 초당 10억개의 UUID를 100년동안 생성한다면 50퍼센트의 충돌이 발생한다고 한다.. 

각 웹서버에서 UUID 생성기를 통해 본인이 사용할 UUID를 사용하기 때문에 구현하기도 쉽고, 확장도 간편하며, 동기화 이슈도 없다. 

하지만 이 방법은 우리가 만들려는 시스템에 적용하기는 문제가 있다.
 - #### 64비트가 아니다.
    UUID는 128비트를 가지는 값이기 때문에 적절하지 않은 값이다.
 - #### 시간순으로 정렬할 수 없다.
    UUID에는 시간에대한 정보를 포함하고 있지 않기 때문이다.
 - #### ID에 숫자가 아닌 값이 포함될 수 있다.
    UUID는 숫자와 문자가 섞여진 문자열값이다.. 전제에 부합하지 않는다.

---

### 티켓서버
티켓서버는 유일성이 보장되는 ID를 발급하는 서버를 따로 두는 것이다. ID를 생성할때 티켓서버를 통해 유일 ID를 발급받고, 이를 데이터베이스에 저장하는 방식이다.
티켓서버는 auto_increment 만을 담당하는 데이터베이스 서버를 중앙 집중형으로 사용한다.

유일성이 보장이 되고, 숫자로 구성된 ID, 시간순서 모두 반영한 ID를 쉽게 생성할 수 있지만.. 이 역시 단점이 존재한다.

- #### 티켓서버가 SPOF가 된다. 
    티켓서버가 장애가 발생하는 경우 해당 서버를 이용하는 모든 시스템에 영향이 간다..
    이 이슈를 피하기 위해 여러 서버를 둘 수 도 있지만 데이터 동기화, 분산 정책 등에 대해 또다시 고민에 빠지게 된다.

---

### 트위터 스노플레이크 접근법
앞서 많은 방법을 소개했지만, 문제의 요구사항을 충족시키기에는 조금씩 부족한 것을 느꼈을 것이다..!
이런 전제를 충족시키기 위해 트위터는 스노플레이크라고 부르는 ID생성기법을 사용한다고 한다.

해당 ID 생성기법은 비트를 나누어서 표현하고 싶은 필드를 지정하는 것이다.

| 비트   | 값        |
|------|----------|
| 1비트  | 사인비트     |
| 41비트 | 타임스탬프    |
| 5비트  | 데이터센터 ID |
| 5비트  | 서버 ID    |
| 12비트 | 일련번호     |

총 64개의 비트를 분할하여 5개의 필드값을 지정하는 방식으로 유일ID를 구현하였다.

각 필드에 대해서 자세하게 살펴보자!
 - #### 사인비트
    음수 및 양수를 구별하는데 사용할 수 있다고 하는데... 아직은 쓰임새가 없다고한다.
 - #### 타임스탬프
    41비트를 차지하고 있는 타임스탬프 부분이다. 시간은 흐름에 따라 점점 큰 값을 가지게 되므로 시간순으로 정렬이 가능하게 변경될 것이다.
    트위터에서는 트위터의 기원시각에 10진수로 변환한 41비트의 값을 더해 시간을 측정한다고한다. 41비트로 표현할 수 있는 기간은 총 69년에 해당한다.
    즉.. 69년 후에는 기원시각을 변경하거나 새로 구성할 필요가 있겠다.
 - #### 데이터센터 ID
    2^5승인 32개의 데이터 센터를 가용할 수 있다는 것을 의미한다.
 - #### 서버 ID
    마찬가지로, 한 데이터센터에서 32개의 서버를 가용할 수 있다는 것을 의미한다.
 - #### 일련번호
    각서버에서 ID를 생성할 때 마다 이 일련번호를 1만큼 증가시키고, 이 값은 일정 시간이 경과할때마다 0으로 초기화된다.
    서버의 가용량에 따라 초기화 주기를 변경한다면 중복되지 않는 ID를 보장할 수 있을것이다.

트위터에서는 이런 비트길이를 가지고 서비스를 운영한다고 하지만, 개발하려는 서비스의 성질에 따라 비트길이를 가변적으로 구성할 수 있다는 점 역시도 큰 장점이라고 생각한다.


이 외에도 고려해야 할 사항들이 몇가지가 있는데
가령 시간 동기화와 관련한 부분과 같은 내용들이 있는데,, 그런 문제점이 있다는 것을 알아만 두자.
