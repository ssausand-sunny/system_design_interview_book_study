## 서론

---

### 검색어 자동완성 기능

> 자동 완성은 Google 검색 내에서 작동하는 기능으로 입력 중인 검색어를 더 빨리 완성할 수 있게 해 줍니다. Google의 자동화 시스템을 통해 생성되는 예상 검색어는 사용자가 의도한 검색어를 빠르게 완성하여 시간을 절약해 줍니다.
>
- 구글에 작성된 글에서 볼 수 있듯 자동완성은 입력 중인 검색어를 기반으로 검색하려는 내용을 예측하여 시간 단축을 할 수 있도록 도와주는 역할을 한다.

시간이 없으니 빠르게 본론으로 넘어가보도록 하자.

## 본론

---

### 조건 제시

- 오늘도 면접은 타이트하게 진행된다. 면접관의 요구사항을 정리해보도록 하자.

1. 자동완성의 기준은 첫 번째 단어부터로 한정한다.
    1. 예를 들어, be를 검색어로 입력했다면 beer, bear는 나오지만 cube는 추천해주지 않는다.
2. 자동완성으로 추천해 줄 단어는 5개이고 선정 기준은 빈도에 따른 인기 순위이다.
3. 맞춤법 검사와 자동수정은 진행하지 않는다.
    1. 구글에서는 이렇게 잘못 검색하면 해주지만 굉장히 복잡할 것 같으니 고려하지 말도록 하자.

   ![Untitled](https://velog.velcdn.com/images/hunnibs/post/842f3c47-c07b-4b43-bf94-cc73c02913dd/image.png)

4. 영어를 기준으로 소문자 검색으로 이루어진다고 가정하며, 가능하다면 다국어 지원도 고려해보자.
5. DAU(Daily Active User)는 천만명이다.

**++추가 요구사항**

- 응답속도는 빠르게 → 100밀리세컨드 안에 자동완성 추천 목록 띄울 것
- 연관성 → 검색어 기반 연관된 자동완성 추천
- 정렬 → 인기도 정렬
- 확장성 → 트래픽에 대한 규모 확장성도 고려

### 대략적 설계

> 사용자 한 명이 10건의 검색, 1문자 = 1바이트, 질의문은 평균적으로 4단어로 구성되며 단어당 5개의 문자가 포함
>

```jsx
QPS(Query per Second) = 100_000 (명) * 10 (건) * 4 (단어) * 5(문자)
			/ {24 (시간) * 60 (분) * 60 (초)
		      = 23_000
```

초당 23_000건의 쿼리를 처리해야한다.  이전에 웹 크롤러에서 초당 처리하려했던 쿼리의 설계가 약 400개였던 것을 기억한다면 자동완성은 엄청난 부하를 주는 것 같다!

### 설계

- 시작하기에 앞서 이전에 자동검색 기능을 구현하기 위해서 설계했던 기억을 되살려보자.

| category_no | keyword | frequency |
| --- | --- | --- |
| 1 | AI | 5 |
| 2 | 인천대학교 | 4 |

하나의 테이블에 모든 키워드 검색을 저장했었기 때문에 category_no로 어떤 자동완성을 원하는지 분류했었다.

- 다음은 책에서 설계한 테이블의 모습이다. (작가님의 오타가 있어 표를 새로 작성했다..)

| query | frequency |
| --- | --- |
| twitter | 35 |
| twitch | 29 |
| twilight | 25 |

기억 속 설계와 똑같이 설계한 것을 볼 수 있다.

- 하지만 책에 따르면 해당 설계는 데이터 양이 적은 경우에 나쁘지 않은 설계안이지만 데이터가 많아질 수록 성능에 병목 현상이 발생한다고 한다.
- 물론 나도 프로젝트 완료 이후 10만건의 데이터를 넣고 자동완성을 하려했을 때 (사실 느려질만한 유의미한 양은 아니었다고 생각) 기분 상 조금 느려진듯한 느낌이 들었었다.

### 상세 설계

- 조금 더 점수를 따기 위해서 그러면 병목 현상을 해결해보도록 하자.
- 크게 두 가지 방법으로 나눌 수 있다. 데이터를 읽을 때와 쓸 때.

- 읽기 성능을 높이는 방법부터 알아보자.
1. 트라이 자료구조

   > “**트라이**(trie)는 [컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)에서 [탐색 트리](https://ko.wikipedia.org/w/index.php?title=%ED%83%90%EC%83%89_%ED%8A%B8%EB%A6%AC&action=edit&redlink=1)의 일종이다. [동적 집합](https://ko.wikipedia.org/wiki/%EC%A7%91%ED%95%A9_(%EC%B6%94%EC%83%81_%EC%9E%90%EB%A3%8C%ED%98%95))이나 [연관 배열](https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B4%80_%EB%B0%B0%EC%97%B4)을 저장하는 데 사용되는 [트리](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0) [자료 구조](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)이다.”
   >

   ![Untitled](https://velog.velcdn.com/images/hunnibs/post/bcb3ea95-4990-4ad9-b60a-b895eff5b474/image.png)

   루트 노드에는 빈 문자열을 저장해놓고 각 노드는 글자 하나를 저장하며 하위 노드는 소문자 기준으로 총 26개의 자식 노드가 생성될 수 있다.

   추가로 리프노드에 작성된 단어에는 빈도수를 함께 저장해놓는다.

    - 트라이 자료구조의 성능을 테스트해보자.

   > 현재 입력받은 단어가 P개라고 가정해보자. 해당 단어에 해당하는 노드를 찾았을 때 연결된 자식 노드의 개수를 C라고 하자.
   >

    ```jsx
    시간복잡도 = O(P) + O(C) + O(ClogC)
    ```

    - 우선 P개의 단어만큼 노드를 타고 내려가고 하위 자식노드 C개를 탐색해 유효한 단어들만을 고른다. 해당 단어들이 최악의 경우 C개 전부라고 해도 정렬을 할 때 ClogC만큼밖에 걸리지 않는다.
    - 반면, 원래의 자료구조를 생각해본다면 총 N개가 저장되있다는 가정 하에 N개를 정렬시키고 N번 탐색을 해야된다. 최악의 경우 O(N) + O(NlogN)의 시간복잡도를 가지게 되는데 N의 단위가 커지면 커질수록 트라이 자료구조를 활용하는 것보다 성능 병목 현상은 심해질 것이다.

1. 인기 검색어 캐시
    1. 성능을 더 올리기 위해서 트라이 자료구조에 적용할 수 있는 방법이다.
    2. 각 노드 당 인기 검색어를 미리 캐시하여 저장해놓는다면 prefix 즉, 위에서 P로 정의한 만큼의 시간만 들인다면 검색어 자동완성 기능을 반환할 수 있다.
    3. 결론적으로 검색어는 최대 50글자 이상을 넘기지 못한다는 제한을 걸어놓는다면 성능은 상수 시간 내로 끝낼 수 있기 때문에 캐시까지 적용한 검색어 자동완성 기법은 **O(1) 시간 안에 해결이 가능하다.**
2. 브라우저 캐싱
    1. 자동완성 검색어 제안 결과는 짧은 시간 안에 바뀌지 않으므로 브로우저 캐시에 넣어두면 후속 질의의 결과는 캐시에서 가져온다.
    2. 구글 검색 엔진에서는 해당 방법을 사용하고 있다.

- 다음은 쓰기 성능을 높이는 방식이다.
1. 저장소의 선택
    1. 문서 저장소 활용 : 몽고디비 같은 문서 저장소를 활용하여 주기적으로 트라이를 직렬화하여 저장한다.
    2. 키-값 저장소 : 트라이에 보관된 모든 접두어를 키로 변환 → 노드에 보관된 캐시 정보를 값으로 보관)

- 마지막으로 확장성을 고려하여 저장소를 분산시키는 방법이다.
1. 샤딩
    1. 1번 서버에는 a부터 m까지, 2번 서버에는 o부터 z까지 저장하는 식으로 분산해서 저장하는 것이다.
    2. 물론 균등하게 나누기 위해서는 좀 더 딥하게 생각해볼 필요가 있지만 해당 부분은 포기하자.

## 결론

### 추가 질문

- 면접을 너무 잘봐서 면접관이 추가로 질문하는 좋은 경우가 나올 수도 있다.
- 질문 리스트는 다음과 같다.

1. 다국어를 지원할 수 있도록 확장성 있게 설계해달라고 했는데 어떻게 해야할까요?
    1. 유니코드(전세계 모든 문자를 컴퓨터가 인식할 수 있는 문자체계)를 이용해 트라이에 넣어버립니다.
2. 다국어가 지원되서 이제 국가별 사용자가 들어오는데 각 국가 별 인기 검색어가 다르면 어떻게 할까요?
    1. CDN을 사용하는 방법이 있습니다. 트라이를 각 국가별 CDN에 저장해서 거기서 꺼내쓰도록 하는 것입니다.
3. 그러면 실시간 검색어 기능도 가능할까요?
    1. 트라이 자료구조는 업데이트에 걸리는 시간을 최소화하고 읽기에 중점을 두었기 때문에 실시간 업데이트 기능을 구현한다면 성능 상 이점을 가져갔던 것이 무효화 됩니다.

이렇게 즐거웠던 면접을 마쳐보자!

**출처**

[구글 고객센터](https://support.google.com/websearch/answer/7368877?hl=ko)

[위키피디아-트라이](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9D%BC%EC%9D%B4_(%EC%BB%B4%ED%93%A8%ED%8C%85))
